import os
from fastapi import FastAPI, Form, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import psycopg2
from psycopg2.extras import RealDictCursor
from dotenv import load_dotenv
import pandas as pd
import requests
import io
from datetime import date

# =======================
# CARGAR VARIABLES DE ENTORNO
# =======================
load_dotenv()
DB_HOST = os.getenv("DB_HOST")
DB_NAME = os.getenv("DB_NAME")
DB_USER = os.getenv("DB_USER")
DB_PASSWORD = os.getenv("DB_PASSWORD")
DB_PORT = int(os.getenv("DB_PORT", 5432))

# =======================
# CONFIGURAR FASTAPI
# =======================
app = FastAPI(title="Aura Verdict API", version="1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"]
)

# =======================
# CONEXIÓN DB
# =======================
def get_db_connection():
    try:
        conn = psycopg2.connect(
            host=DB_HOST,
            database=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            port=DB_PORT,
            cursor_factory=RealDictCursor
        )
        return conn
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"DB connection failed: {e}")

# =======================
# FUNCIONES DE INGEST
# =======================
DATASETS = {
    "cpt_pfs": "https://data.cms.gov/data-api/v1/dataset/medicare-physician-fee-schedule.csv",
    "opps_asc": "https://data.cms.gov/data-api/v1/dataset/opps-asc.csv",
    "gpci": "https://data.cms.gov/data-api/v1/dataset/medicare-gpci.csv",
    "percentiles": "https://raw.githubusercontent.com/your-org/cms-percentiles/master/cms_percentiles.csv"
}

def download_csv(url):
    r = requests.get(url, timeout=120)
    r.raise_for_status()
    return pd.read_csv(io.BytesIO(r.content))

def ingest_aura_data():
    conn = get_db_connection()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS aura_cpt_benchmarks (
            cpt TEXT,
            state CHAR(2),
            fair_price NUMERIC,
            national_avg NUMERIC,
            p85_price NUMERIC,
            gpci NUMERIC,
            local_price NUMERIC,
            updated_at DATE,
            PRIMARY KEY (cpt, state)
        );
    """)
    conn.commit()

    # PFS
    df_cpt = download_csv(DATASETS["cpt_pfs"])
    df_cpt = df_cpt.rename(columns={
        "hcpcs_code": "cpt",
        "average_submitted_charge_amount": "avg_price",
        "provider_state": "state"
    })
    df_cpt = df_cpt[["cpt","state","avg_price"]].dropna()
    df_cpt["avg_price"] = df_cpt["avg_price"].astype(float)

    # OPPS / ASC
    df_opps = download_csv(DATASETS["opps_asc"])
    df_opps = df_opps.rename(columns={
        "hcpcs_code": "cpt",
        "average_submitted_charge_amount": "avg_price",
        "provider_state": "state"
    })
    df_opps = df_opps[["cpt","state","avg_price"]].dropna()
    df_opps["avg_price"] = df_opps["avg_price"].astype(float)

    # Combinar
    df_all = pd.concat([df_cpt, df_opps])
    df_all = df_all.groupby(["cpt","state"]).agg(
        fair_price=("avg_price","median"),
        national_avg=("avg_price","mean")
    ).reset_index()

    # GPCI
    df_gpci = download_csv(DATASETS["gpci"])
    df_all = df_all.merge(df_gpci[["state","gpci"]], on="state", how="left")
    df_all["local_price"] = df_all["fair_price"] * df_all["gpci"]

    # Percentiles P85
    df_pct = download_csv(DATASETS["percentiles"])
    df_all = df_all.merge(df_pct[["cpt","state","p85"]].rename(columns={"p85":"p85_price"}), on=["cpt","state"], how="left")

    # Insert/update DB
    df_all["updated_at"] = date.today()
    for _, row in df_all.iterrows():
        cur.execute("""
            INSERT INTO aura_cpt_benchmarks
            (cpt,state,fair_price,national_avg,p85_price,gpci,local_price,updated_at)
            VALUES (%s,%s,%s,%s,%s,%s,%s,%s)
            ON CONFLICT (cpt,state) DO UPDATE SET
                fair_price = EXCLUDED.fair_price,
                national_avg = EXCLUDED.national_avg,
                p85_price = EXCLUDED.p85_price,
                gpci = EXCLUDED.gpci,
                local_price = EXCLUDED.local_price,
                updated_at = EXCLUDED.updated_at
        """, (
            row.cpt,row.state,row.fair_price,row.national_avg,row.p85_price,row.gpci,row.local_price,row.updated_at
        ))
    conn.commit()
    cur.close()
    conn.close()
    print(f"✅ INGESTA AURA COMPLETA: {len(df_all)} registros actualizados")

# =======================
# Ejecutar ingest al iniciar la app
# =======================
ingest_aura_data()

# =======================
# ENDPOINT ESTIMADO
# =======================
@app.post("/estimado")
def estimado(consulta: str = Form(...), lang: str = Form("es"), zip_user: str = Form(None)):
    conn = get_db_connection()
    cursor = conn.cursor()
    cpt_code = consulta.upper()

    # Consulta por ZIP si existe
    if zip_user:
        cursor.execute("""
            SELECT * FROM aura_cpt_benchmarks
            WHERE cpt=%s AND state=(SELECT state FROM aura_cpt_benchmarks WHERE state=(SELECT state FROM aura_cpt_benchmarks LIMIT 1) LIMIT 1)
        """, (cpt_code,))
    else:
        cursor.execute("""
            SELECT * FROM aura_cpt_benchmarks
            WHERE cpt=%s
        """, (cpt_code,))

    row = cursor.fetchone()
    conn.close()

    if not row:
        return JSONResponse({"resultado": lang=="es" and "Código no encontrado" or "Code not found"}, status_code=404)

    resultado = f"""
CPT: {row['cpt']}
Estado: {row['state']}
Precio justo (Mediana CMS): ${row['fair_price']:.2f}
Precio local ajustado (GPCI): ${row['local_price']:.2f}
Precio premium (p85 percentil): ${row['p85_price']:.2f}
Fuente: CMS + GPCI + Percentiles públicos
Nota legal: Estimado legalmente defendible, datos públicos.
"""
    return {"resultado": resultado.strip()}

# =======================
# LOGIN ADMIN GRATUITO
# =======================
@app.post("/login-admin")
def login_admin(user: str = Form(...), pw: str = Form(...)):
    if user=="admin" and pw=="aura2026":
        return {"success": True}
    else:
        raise HTTPException(status_code=401, detail="Usuario o contraseña incorrectos")

# =======================
# HEALTH CHECK
# =======================
@app.get("/health")
def health():
    try:
        conn = get_db_connection()
        conn.close()
        return {"status": "ok"}
    except:
        raise HTTPException(status_code=500, detail="DB connection failed")
